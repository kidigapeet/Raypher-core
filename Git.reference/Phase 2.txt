This is your definitive, comprehensive **Phase 2 Execution Plan: The "Ghost" Protocol**.

You have built the engine (Phase 1). Now you must build the **Vehicle**.
A security tool that requires a terminal window to stay open is not a security tool; it is a toy. To be "Enterprise Ready," Raypher must be invisible, unkillable, and omnipresent.

---

# **Phase 2: The "Ghost" Protocol (Invisibility & Persistence)**

**Goal:** Transform `raypher.exe` from a CLI tool into a **System Service** that runs automatically on boot, protects itself from termination, and manages API keys securely.
**Timeline:** 4 Weeks.

---

### **The Architecture Shift**

You are moving from **User Mode** (running as you) to **System Mode** (running as Root/Administrator).

| Feature | **Phase 1 (Current)** | **Phase 2 (Target)** |
| --- | --- | --- |
| **Visibility** | Terminal Window Open | **Invisible Background Process** |
| **Lifespan** | Dies when you close window | **Starts on Boot / Restarts on Crash** |
| **Identity** | "Kidigapeet's Process" | **"SYSTEM" / "ROOT" User** |
| **API Keys** | Hardcoded in `.env` | **Intercepted via Local Proxy** |
| **Updates** | `git pull && cargo run` | **Auto-Update via Cloud** |

---

### **Week 5: The "Daemon" (Service Refactor)**

**Objective:** Make the code capable of running as a Windows Service and a Linux Daemon.

#### **Founder 1 (Cybersecurity) – The Windows Service (`windows-service`)**

* **The Challenge:** Windows Services are not just "loops." They must respond to the Service Control Manager (SCM) signals (Start, Stop, Pause). If you don't "check in" with SCM, Windows kills your service.
* **The AI Prompt:**
> "Refactor `main.rs` to support running as a Windows Service.
> 1. Add `windows-service` crate.
> 2. Create a function `run_service()` that registers the service dispatcher.
> 3. Implement the event handler to catch `ServiceControl::Stop` and trigger our `AtomicBool` shutdown flag.
> 4. **Critical:** Ensure the service reports its status as `Running` to the OS within 30 seconds, or the install will fail."
> 
> 



#### **Co-Founder (Data/Ops) – The Linux Daemon (`systemd`)**

* **The Challenge:** Linux uses `systemd`. You need to create a "Unit File" that tells Linux how to treat Raypher.
* **The AI Prompt:**
> "Create a `systemd` unit file template `raypher.service`.
> 1. `ExecStart=/usr/local/bin/raypher monitor`
> 2. `Restart=always` (If it crashes, restart it instantly).
> 3. `User=root` (We need permission to kill other processes).
> 4. `WantedBy=multi-user.target` (Start when the OS boots)."
> 
> 


* **Your "Senior" Review:**
* **Panic Handling:** If Raypher crashes in a loop (e.g., DB is locked), `Restart=always` will cause a "Restart Loop" that burns 100% CPU. Add `StartLimitIntervalSec=60` to prevent this.



---

### **Week 6: The "Vault" (Localhost Proxy)**

**Objective:** The "Man-in-the-Middle" feature. Raypher sits between the Agent and the Internet to inject secrets.

#### **Founder 1 (Cybersecurity) – The Proxy Server (`axum`)**

* **The Challenge:** You need a high-speed HTTP server that listens on `127.0.0.1:8888`.
* **The AI Prompt:**
> "Create a module `proxy.rs` using the `axum` and `reqwest` crates.
> 1. Start a server on `127.0.0.1:8888`.
> 2. Accept POST requests to `/v1/chat/completions` (OpenAI compatible endpoint).
> 3. **The Intercept:** When a request comes in:
> a. Check the header `X-Raypher-Token`.
> b. Verify the calling Process ID (PID) using `sysinfo`.
> c. If valid, retrieve the *real* API Key from the TPM module (Phase 1).
> d. Inject `Authorization: Bearer sk-REAL-KEY` and forward the request to `api.openai.com`."
> 
> 



#### **Co-Founder (Data/Ops) – The Secret Manager**

* **The Challenge:** How does the user put the key in initially?
* **The AI Prompt:**
> "Add a CLI command `raypher seal`.
> 1. Prompt user: 'Enter API Key'.
> 2. Encrypt the key using the TPM public key (from Phase 1).
> 3. Store the *encrypted* blob in `data.db` under a new table `secrets`."
> 
> 


* **Your "Senior" Review:**
* **Latency:** The proxy adds latency. Ensure `reqwest` reuses connections (Keep-Alive) or your agents will be slow.



---

### **Week 7: The "Factory" (Installers & CI/CD)**

**Objective:** You cannot ask a lawyer to install Rust. You need a `.msi` file.

#### **Founder 1 (Cybersecurity) – The Windows Installer (`cargo-wix`)**

* **The Challenge:** Building a professional Windows Installer (MSI) that registers the Service automatically.
* **The AI Prompt:**
> "Use `cargo-wix` to generate a Windows Installer.
> 1. Initialize with `cargo wix init`.
> 2. Edit `main.wxs` to include a `<ServiceInstall>` tag.
> 3. Configure it to start 'Automatic' on startup.
> 4. Sign the binary (Self-signed for now, Buy a certificate later)."
> 
> 



#### **Co-Founder (Data/Ops) – The Build Pipeline (GitHub Actions)**

* **The Challenge:** Automate the build so you don't do it manually on your laptop.
* **The AI Prompt:**
> "Create a GitHub Actions workflow `release.yml`.
> 1. Trigger on: `push tags: v*`.
> 2. Job 1 (Linux): Build `raypher-linux-amd64` using `ubuntu-latest`.
> 3. Job 2 (Windows): Build `raypher-windows.msi` using `windows-latest` and `cargo wix`.
> 4. Upload artifacts to the GitHub Release page."
> 
> 


* **Your "Senior" Review:**
* **Cross-Compilation:** Rust makes this easy, but `openssl` is painful. Use `rustls` instead of `openssl` (native Rust TLS) to avoid "DLL Hell" on Windows.



---

### **Week 8: The "Immortal" (Self-Update & Watchdog)**

**Objective:** Raypher must update itself and refuse to die.

#### **Founder 1 (Cybersecurity) – The Watchdog**

* **The Challenge:** A virus will try to `taskkill raypher.exe`.
* **The Strategy:** On Windows, set the **Service Recovery Actions**.
* **The AI Prompt:**
> "Configure the Windows Service to 'Restart the Service' on failure (First, Second, and Subsequent failures). This makes it very annoying to kill."



#### **Co-Founder (Data/Ops) – The Auto-Updater (`self_update`)**

* **The Challenge:** Pushing patches to 1,000 machines.
* **The AI Prompt:**
> "Implement `self_update` crate in `main.rs`.
> 1. Check GitHub Releases for a newer version tag (e.g., `v0.2.0`).
> 2. If found, download the binary in the background.
> 3. **The Swap:** On Windows, you can't replace a running `.exe`. Rename the current exe to `raypher.exe.old`, move the new one in, and restart the service."
> 
> 



---

### **The "Ghost" User Experience (What you are building)**

1. **Installation:**
* User downloads `RaypherSetup.msi`.
* Double-clicks. "Next, Next, Finish."
* *Result:* Raypher is now running. No window opens.


2. **Configuration:**
* User opens PowerShell: `raypher seal` -> Enters OpenAI Key.
* *Result:* Key is locked in TPM.


3. **Operation:**
* User runs their agent: `python agent.py`.
* Agent tries to hack something -> **Raypher blocks it silently.**
* User checks logs: `raypher logs` -> Sees the block event.


4. **Persistence:**
* User reboots the laptop.
* Raypher is already running before the user logs in.



### **Final Checklist for Phase 2**

* [ ] Does `cargo run -- monitor` handle `Ctrl+C` gracefully? (Done)
* [ ] Can you install it as a Windows Service?
* [ ] Does the Proxy (`:8888`) successfully forward to OpenAI?
* [ ] Does the MSI installer work on a fresh Windows VM?
* [ ] Does the GitHub Action produce a downloadable release?

**You are now building a Platform, not just a Tool.**


This is the engineering deep dive into **Phase 2: The Ghost Protocol**. You are asking to understand the "nuts and bolts" of how we turn a simple Rust program into a persistent, unkillable Windows Service.

Here is the expanded breakdown of each component.

### **1. The "Factory" Infrastructure (The Assembly Line)**

You cannot just email a `.exe` file to a corporate IT department. They will block it. You need an **MSI (Microsoft Installer)**. This is a database file that tells Windows exactly where to put files, what registry keys to create, and how to uninstall everything cleanly.

* **WiX Toolset (The Compiler):**
* Think of WiX as the "C++ of Installers." It uses XML configuration files (`.wxs`) to describe the installation.
* **Why it's critical:** It allows you to define "Custom Actions." For Raypher, we need a custom action that says: *"After copying the files, immediately tell the Service Control Manager to register 'RaypherService' and start it."*
* **The alternative:** If you don't use WiX, you have to write a batch script (`install.bat`). Batch scripts are fragile, trigger antivirus warnings, and look unprofessional.


* **Cargo WiX (The Bridge):**
* Writing raw WiX XML is painful. `cargo-wix` looks at your `Cargo.toml` (version, author, description) and auto-generates the `main.wxs` file for you.
* **The Magic:** It handles the UUID generation. Every MSI needs a unique "ProductCode" UUID. If you change the version from 0.1.0 to 0.2.0, `cargo-wix` updates this UUID so Windows knows it's an *upgrade*, not a new app.



### **2. The "Runtime" Infrastructure (The Host Environment)**

We are demanding specific things from the user's laptop.

* **Privilege Level: `LocalSystem` vs. `Administrator`:**
* When you run a terminal as "Admin," you are still a user.
* **`LocalSystem`** is a pseudo-account used by the OS kernel. It has higher privileges than Admin. It acts as the computer itself.
* **Why Raypher needs this:**
* To kill malware that is running as Admin.
* To access the TPM chip (which requires raw hardware access).
* To listen on Port 8888 without triggering the Windows Firewall popup every time.




* **TPM 2.0 (The Hardware Root of Trust):**
* The TPM is a separate microcontroller on the motherboard.
* **Why we need it:** If hackers steal the `data.db` file (where we store secrets), they can't decrypt it because the decryption key is burned into the TPM silicon of *that specific laptop*.
* **The Constraint:** This means Raypher will not work on very old laptops (pre-2016). This is a trade-off we accept for security.



### **3. The "Ghost" Architecture (The Split Brain)**

This is the most complex code change. Your `main.rs` binary now has to have a "Split Personality."

* **Personality A: The CLI (User Mode)**
* Triggered when you type `raypher scan` or `raypher seal`.
* It prints text to the console (`stdout`).
* It exits when the task is done.


* **Personality B: The Service (System Mode)**
* Triggered *only* by the Windows Service Control Manager (SCM).
* **It has no console.** If you try `println!("Hello")`, it goes nowhere (or crashes).
* **The "Handshake":** When it starts, it has about 30 seconds to send a "Status Report" to the SCM saying *"I am running!"* If it fails to do this (e.g., because it's stuck waiting for a database lock), Windows assumes it hung and kills it.
* **The Dispatcher:** This is why we need the `windows-service` crate. It handles this heartbeat "ping" to the OS for us.



### **4. The "Watchdog" (The Zombie Protocol)**

You asked about `sc failure`. This is built-in Windows resilience.

* **The Problem:** Rust panics. If your code hits an unwrap on a `None` value, the program crashes.
* **The Fix:** We tell Windows: *"If this process dies unexpectedly, resurrect it."*
* **Restart/1000:** Wait 1 second, then restart.
* **Reset=86400:** If it's been running fine for 24 hours, reset the crash counter to zero.


* **Why this is better than a loop:** If you write `loop { run() }` inside your Rust code, a panic will still kill the whole process. By letting the *OS* handle the restart, you get a clean slate (fresh memory) every time.

### **5. The "Vault" Flow (The Interceptor)**

This is how we protect API keys without the user changing their code.

1. **The Trigger:** The user's Python script runs:
`requests.post("http://localhost:8888/v1/chat/completions", headers={"X-Raypher-Token": "dummy"})`
2. **The Pause:** Raypher's `axum` server receives the request. It does **not** forward it yet.
3. **The CSI Investigation (The Hard Part):**
* Raypher looks at the TCP connection metadata.
* It asks the OS Kernel: *"Which Process ID (PID) owns the other end of this TCP socket?"*
* OS says: *"PID 4512."*


4. **The Verification:**
* Raypher scans PID 4512.
* Calculates the SHA-256 hash of the `.exe`.
* Compares it to the "Allow List" in `data.db`.


5. **The Action:**
* **Match:** Raypher asks TPM to decrypt the *real* OpenAI key, injects it into the header, and sends it to OpenAI.
* **No Match:** Raypher drops the connection. The script gets a "Connection Reset" error.